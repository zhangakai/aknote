#设计模式

---------------------------------------------------------------
耦合：耦合是软件模块之间的相互依赖程度

内聚：内聚指的是一个模块内的元素在多大程度上属于一个整体。在某种意义上，
它是对一个类的方法和数据与该类的一些统一目的或概念之间关系强度的衡量。

设计模式就是围绕这两个概念转。

设计模式六大准则

    1.S 单一职责原则 - 一个类（方法、接口也行）只负责一个功能领域中的相应职责
    2.L 里氏替换原则 - 只要父类出现的地方子类就一定可以出现,而且替换为子类也不会出现任何异常或错误
    3.D 依赖倒置原则 - 高层模块不应该依赖低层模块,两者都应该依赖其抽象（大白话-面向接口编程）
    4.I 接口隔离原则 -
    5.D 迪米特法则 - 一个对象应该对其他对象有最少的了解
    6.O 开闭原则 -  一个软件实体如类,模块和函数应该对扩展开放,对修改关闭

按照四人帮的定义，设计模式总共23种，5种创建型（怎么样创建对象），7种结构型（怎么布局架构），
11种行为型（类或对象之间怎么协作）。

-------------------------------------------------------

创建型之单例模式

    定义：指一个类只有一个实例，且该类能自行创建这个实例（饿汉式 懒汉式）
    目的：节省内存资源、保证数据内容的一致性
    优点：
    1.减少了内存的开销，优化和共享资源的访问
    缺点：
    1.一般没有接口，扩展困难
    2.单元测试困难 因为单例对象的状态全局一致
    例子：
    spring里面controller service一般都是单例模式
    ApplicationContext也是单例
    数据库的连接池  应用程序的日志对象
    太多了 

工厂方法模式

    定义：提供了一个用于创建对象的接口，但允许子类更改将要创建的对象的类型，
    使用特殊的工厂方法代替对于对象构造函数的直接调用。
    场景：
    1.无法预知对象确切类别及其依赖关系时
    2.用户能扩展软件库或框架的内部组件
    优点：
    1.调用工厂方法的代码无需了解不同子类返回实际对象之间的差别。
    2.扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
    3.避免创建者和具体产品之间的紧耦合，遵循单一职责原则（可以将产品创建
    代码放在程序的单一位置， 从而使得代码更容易维护。）
    和开闭原则（无需更改现有客户端代码， 你就可以在程序中引入新的产品类型）
    缺点：
    1.应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。
    例子
    接口 ThreadFacotory 方法 public Thread newThread(Runnable r)
    实现类DefaultThreadFactory 返回一个非守护线程 普通优先级
    实现类CustomThreadFactory(SocketStreamHandle类里面的) 返回一个守护线程 普通优先级

抽象工厂

     定义：围绕一个超级工厂创建其他工厂，create objects that follow a general pattern
    场景：代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息
    优点： 
    1.可以确保同一工厂生成的产品相互匹配。
    2.单一职责原则和开闭原则。
    缺点：
    1.由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。
    例子：
    JFormattedTextField.AbstractFormatterFactory 
    DefaultFormatterFactory extends 上面

建造者模式
    
    定义：使用多个简单的对象一步一步构建成一个复杂的对象，将复杂对象的构建与它的表示分离
    场景：假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作
    不优雅的方法：超级构造函数 、拓展基类
    解决：将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。
    优点：
    1. 可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
    2.生成不同形式的产品时， 可以复用相同的制造代码
    3.单一职责原则
    缺点： 
    1.由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。
    例子：
    1.StringBuilder 
    2.MapStruct
    

原型模式

    定义：原型模式将克隆过程委派给被克隆的实际对象；用于创建重复的对象，同时又能保证性能
    解决：模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象， 
    同时又无需将代码和对象所属类耦合。通常情况下， 这样的接口中仅包含一个克隆方法。
    场景：当直接创建对象的代价比较大时，则采用这种模式
    优点：
    1.性能提高。 2.逃避构造函数的约束
    3.克隆预生成原型，避免反复运行初始化代码
    4.能在不知晓对象类型的情况下生成一个与其完全相同的复制品
    -- 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。
    但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`
    方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，
    我们将获得一个正确的复制品，而不是一组简单的形状对象。
    缺点：
    1.克隆包含循环引用的复杂对象可能会非常麻烦。
    例子：
    1.实现 Cloneable，重写clone()--这个方法并不是Cloneable里面的 是Object里面的
    2.细胞分裂


------------------------------------------------------------

结构型

适配器模式

    定义：作为两个不兼容的接口之间的桥梁，使接口不兼容的对象能够相互合作
    目的：解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，
    而新环境要求的接口是现对象不能满足的。
    场景：
    1.系统需要使用现有的类，而此类的接口不符合系统的需要
    2.创建一个中间层类， 其可作为代码与遗留类、 第三方类之间的转换器。
    优点：
    1.单一职责原则 可以将接口或数据转换代码从程序主要业务逻辑中分离
    2.开闭原则 只要客户端代码通过客户端接口与适配器进行交互
    3.提高复用性 灵活性好
    就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。
    缺点：
    1.过多地使用适配器，会让系统非常零乱，不如重构
    例子：
    1.EnumerationIterator  org.apache.commons.collections4.iterators
    Iterator iterator = new EnumerationIterator(enumeration);
    2.public InputStreamReader(InputStream in,String charsetName) 返回一个Reader
    3.Arrays.asList()


桥接模式（没搞懂）

    定义：一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，
    从而能在开发时分别使用。
    解决：桥接模式通过将继承改为组合的方式来解决--在两个不同的维度上拓展类 这个问题
    场景：
    1.一个类存在多个独立变化的维度，且这些维度都需要进行扩展。
    2.不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统
    优点：
    1.可以创建与平台无关的类和程序
    2.客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。
    3. 开闭原则--可以新增抽象部分和实现部分， 且它们之间不会相互影响。
    单一职责原则--抽象部分专注于处理高层逻辑实现部分处理平台细节。
    缺点：
    1.对高内聚的类使用该模式可能会让代码更加复杂。
    例子：
    1.JDBC的设计
    interface Driver
    Connection connect(String url, java.util.Properties info)
        throws SQLException;
    Connection也是一个接口

组合模式

    定义：一种结构设计模式，可让对象组合成树结构，然后将这些树结构当作单独的对象来处理
    将对象组合成树形结构以表示“部分-整体”的层次结构
    场景：希望用户忽略组合对象与单个对象的不同
    解决：树枝和叶子实现统一接口，树枝内部组合该接口
    优点：
    1.高层模块调用简单。 2.节点自由增加。
    缺点：
    1.对于功能差异较大的类， 提供公共接口或许会有困难。 
    例子：
    暂时没找到好的


装饰器模式

    定义：动态地给一个对象添加一些额外的职责，就增加功能来说，相比生成子类更为灵活。
    场景：没法在编译时就确定一个对象的功能，需要运行时动态的给对象添加职责，
    所以只能把对象的功能拆成一一个个的小部分，动态组装
    优点：
    1.无需创建新子类即可扩展对象的行为。
    2.可以在运行时添加或删除对象的功能
    3.单一职责原则--将实现了许多不同行为的一个大类拆分为多个较小的
    缺点：
    1.在封装器栈中删除特定封装器比较困难；实现行为不受装饰栈顺序影响的装饰比较困难
    例子：
    在Java标准库中，InputStream是抽象类，FileInputStream、ServletInputStream、Socket.getInputStream()
    这些InputStream都是最终数据源。现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，
    那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，
    这种设计方式显然是不可取的。
    正确做法：InputStream input = new GZIPInputStream( // 第二层装饰
                        new BufferedInputStream( // 第一层装饰
                            new FileInputStream("test.gz") // 核心功能
                        ));
    



Facade Design Pattern（门面或外观）

    定义：为子系统中的一组接口提供一个一致的界面。
    目的：为复杂的子系统提供简单的接口，对客户端隐藏了子系统的复杂性
    优点：
    1.减少了外部代码对库内部工作的依赖性，从而提供了灵活性
    2.使系统易于使用和维护，并减少库或其他包之间的依赖关系
    3.更好的划分访问层次：有些方法是对系统外的，有些方法是系统内部相互交互的使用的。
    子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，
    很好的隐藏了子系统内部的细节。
    缺点：
    1.子系统的方法与Façade层相连。
    如果子系统的结构发生变化，那么就需要对Facade层进行后续的改变


    场景：
    1.org.apache.catalina.connector.RequestFacade 
    org.apache.catalina.connector.Request一些方法不想对外开放
    2.SLF4J 是简单的日志外观模式框架，抽象了各种日志框架例如 
    Logback、Log4j、Commons-logging 和 JDK 自带的 logging 实现接口。
    它使得用户可以在部署时使用自己想要的日志框架。


享元模式

    定义：运用共享技术有效地支持大量细粒度的对象。享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，
    而不是新创建实例，从而实现不可变实例的复用。
    目的：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，
    直接向调用方返回一个共享的实例就行
    场景：
    1.仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式
    2.对象的状态大部分可以外部化（即将原来的对象拆成不可变的内部状态和可变的外部状态来节约内存）
    优点：
    1.省内存
    缺点：
    1.拆分出不可变对象可能会使系统变得复杂
    例子：
    1.Java的String缓存 Integer缓存 等待
    2.各种缓存

代理模式

    定义：代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。
    场景：
    1.对象不可直接访问或需要安全控制等；想在访问一个类时做一些控制。
    2.本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。
    3.记录日志请求 （日志记录代理）。
    4.延迟初始化 （虚拟代理）。
    优点：
    1.开闭原则-可以在不对服务或客户端做出修改的情况下创建新代理。
    2.可以在客户端毫无察觉的情况下控制服务对象。
    缺点：
    1.代码可能会变得复杂， 因为需要新建许多类。
    2.客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
    例子：
    太多了 Spring几乎全是代理

-------------------------------------------------------

行为型模式


责任链模式

    定义；责任链会将特定行为转换为被称作处理者的独立对象，
    每个检查步骤都可被抽取为仅有单个方法的类， 并执行检查操作。 
    责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
    场景：
    1.当程序需要使用不同方式处理不同种类请求，
    而且请求类型和顺序预先未知时， 可以使用责任链模式。
    优点：
    1.降低耦合度。它将请求的发送者和接收者解耦。
    2.增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，
    允许动态地新增或者删除责任。
    缺点：
    1. 部分请求可能未被处理。
    例子：Spring filter 


命令模式

    定义：命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。
    场景：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。
    优点：
    1.将请求封装为对象，从而允许对具有不同请求的客户端进行参数化，
    以及对请求进行排队或记录，允许支持可撤销的操作。
    2.可以实现撤销和恢复功能；可以实现操作的延迟执行；可以将一组简单命令组合成一个复杂命令。
    缺点：
    1.代码可能会变得更加复杂， 因为在发送者和接收者之间增加了一个全新的层次。
    例子：
    1.GUI 中每一个按钮都是一条命令
    2.CMD

解释器模式

    定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    场景：解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，
    使得通过代码来实现非常不灵活
    优点：
    1.可扩展性比较好，灵活 2.易于实现简单文法
    缺点：1.实现复杂 且一般只能解决一类特定问题。
    例子：
    1.String s = "+861012345678";
    System.out.println(s.matches("^\\+\\d+$"))
    2.执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码

迭代器模式

    定义：迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。
    目的：迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。
    场景：
    1.当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 
    （出于使用便利性或安全性的考虑），可以使用迭代器模式。
    2.使用该模式可以减少程序中重复的遍历代码。
    优点：
    1.单一职责原则-通过将体积庞大的遍历算法代码抽取为独立的类
    2.可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。
    3.开闭原则-可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。
    缺点：
    1.对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。
    2.增加新的聚合类需要对应增加新的迭代器类，在一定程度上增加了系统的复杂性。
    例子：
    1.JAVA 中的 iterator

中介者模式

    定义：用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，
    从而使其耦合松散，而且可以独立地改变它们之间的交互。
    目的：多个类相互耦合，形成了网状结构，将网状结构分离为星型结构
    场景：
    1.当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。
    2.当一些对象和其他对象紧密耦合以致难以对其进行修改时
    优点：
    1.可以减轻应用中多个组件间的耦合情况
    2.可以更方便地复用各个组件
    3.开闭原则-无需修改实际组件就能增加新的中介者
    4.降低了类的复杂度，将一对多转化成了一对一
    缺点：
    1. 一段时间后， 中介者可能会演化成为上帝对象（一个了解过多或者负责过多的对象）
    例子：
    1. 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 
    2.机场调度系统。 
    3.MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者

备忘录模式

    定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
    具体操作：模式建议将对象状态的副本存储在一个名为备忘录 （Memento） 的特殊对象中。除了创建备忘录的对象外， 
    任何对象都不能访问备忘录的内容。 其他对象必须使用受限接口与备忘录进行交互，
    它们可以获取快照的元数据 （创建时间和操作名称等）， 但不能获取快照中原始对象的状态。
    优点：
    1.在不破坏对象封装情况的前提下创建对象状态快照
    2.使用户能够比较方便地回到某个历史的状态。
    缺点：
    1.需要保存/恢复数据的相关状态场景；提供一个可回滚的操作   
    例子：
    1.CTRL+z 2.事务


观察者模式（订阅-发布）

    定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，
    所有依赖于它的对象都得到通知并被自动更新
    优点：