#一些基础知识

---------------------------------------------------------

进程、线程

    进程:程序在某个数据集合上的一次执行过程，可以把它看作成充分描述程序已经执行到何种程度的数据结构的汇集。
    线程:进程中的一个执行流。
    

Linux进程状态

    task_running:将就绪态和运行态合二为一 
    task_interruptiable:可中断阻塞
    task_uninterruptiable:不可中断阻塞（比如打开设备文件）
    task_stopped:执行被暂停（收到signstop/signout/信号等）
    task_traced:debugger情况
    exit_zombie:进程中止了(do_exit) 等待父进程调用wait方法
    exit_dead:父进程调用了wait方法，防止其他线程重复调用，会进入这个状态

Linux task_struct

    主要包含6部分
    thread_info-进程的基本信息 mm_struct-指向内存区描述符的指针
    tty_struct-设备信息 fs_struct-当前目录 files_struct-文件描述符
    signal_struct-接收的信号
    还有其他很多字段

    Pid:默认最大值为32767(2的15次方-1 即一个页框（4kB=4*1024*8） 循环使用 可在/proc/sys/kernel/pid_max文件中修改
    64位中最大可以扩大到4194303（2的22次方）
    同一个进程中所有线程pid相同
    

进程切换

    1.切换全局页目录以安装一个新的地址空间
    2.切换内核态堆栈和硬件上下文，内核态堆栈放eax/ebx/esp/ebp等通用寄存器
    硬件上下文放其他CPU寄存器（task_struct的thread字段就是保存硬件上下文的地方）

进程调度

    1.先来先到
    容易实现 效率不高 不利于短作业
    2.短作业优先
    易于实现 效率不高 容易造成饥饿现象
    3.响应比优先
    响应比=（等待时间+运行时间）/运行时间=1+等待/运行
    有利于短作业 有利于长等待
    4.优先数调度
    进程优先数=静态优先数(初始分配)+动态优先数 (动态调整)
    静态 基于进程所需资源多少 运行时间长短 基于进程类型
    动态 基于cpu使用时长（超过一定时间） 等待时长
    5.轮转
    分为小的时间片 挨个来
    时间片大小不好拿捏
    6.多级反馈队列（Multi-Level Feedback Queue）调度算法
    设置多个就绪队列，并为各个队列赋予不同的优先级。
    第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。
    仅当第1～i-1个队列均为空时，操作系统调度器才会调度第i个队列中的进程运行。
    赋予各个队列中进程执行时间片的大小也各不相同。在优先级越高的队列中，每个进程的执行时间片就越小或越大（Linux-2.4内核就是采用这种方式）。
    当一个就绪进程需要链入就绪队列时，操作系统首先将它放入第一队列的末尾，按FCFS的原则排队等待调度。
    若轮到该进程执行且在一个时间片结束时尚未完成，则操作系统调度器便将该进程转入第二队列的末尾，再同样按先来先服务原则等待调度执行。
    如此下去，当一个长进程从第一队列降到最后一个队列后，在最后一个队列中，可使用FCFS或RR调度算法来运行处于此队列中的进程。
    如果处理机正在第i（i>1）队列中为某进程服务时，又有新进程进入第k（k<i）的队列，则新进程将抢占正在运行进程的处理机，
    即由调度程序把正在执行进程放回第i队列末尾，重新将处理机分配给处于第k队列的新进程。
    

内存分配算法

    1.Buddy算法
    把空闲的页以2的n次方为单位进行管理 
    以产生内部碎片为代价来避免外部碎片的产生
    2.首次适配（first fit）算法的分配内存的设计思路是物理内存页管理器顺着双向链表进行搜索空闲内存区域，
    直到找到一个足够大的空闲区域，这是一种速度很快的算法，因为它尽可能少地搜索链表。
    如果空闲区域的大小和申请分配的大小正好一样，则把这个空闲区域分配出去，成功返回；
    否则将该空闲区分为两部分，一部分区域与申请分配的大小相等，把它分配出去，剩下的一部分区域形成新的空闲区。
    其释放内存的设计思路很简单，只需把这块区域重新放回双向链表中即可。

    最佳适配（best fit）算法的设计思路是物理内存页管理器搜索整个双向链表（从开始到结束），
    找出能够满足申请分配的空间大小的最小空闲区域。找到这个区域后的处理以及释放内存的处理与上面类似。
    最佳适配算法试图找出最接近实际需要的空闲区，名字上听起来很好，其实在查询速度上较慢，且较易产生多的内存碎片。

    最差适配（worst fit）算法与最佳适配（best fit）算法的设计思路相反，
    物理内存页管理器搜索整个双向链表，找出能够满足申请分配的空间大小的最大空闲区域，
    使新的空闲区比较大从而可以继续使用。在实际效果上，查询速度上也较慢，产生内存碎片相对少些。
    

死锁

    必要条件
    1.互斥 2.不可剥夺 3.部分分配 4.环路
    预防死锁
    破坏上面四个条件任意一个即可
    12难度过大 3可以用预先分配好全部资源解决 4.可以使用有序资源分配
    避免死锁
    银行家算法（实现较难）
     


    
    
        