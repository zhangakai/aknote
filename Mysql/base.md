#高性能mysql总结

---------------------------------------

    脏读 指在不同的事务下 当前事务可以读到另外事务未提交的数据
    
    不可重复读  一个事务多次读取同一数据集合 在这个事务还没有结束时 另一个事务访问同一集合且做了
    修改 那么第一个事务两次读到的数据可能是不一样的


    索引的优点:
    1.大大减少了需要扫面的数据量
    2.可以帮助避免排序和临时表
    3.可以将随机IO变成顺序IO　
    mike leach提出三星标准:1.索引将相关的记录放在一起则获得一星
    2.索引中的数据顺序和查找中的排序顺序一致则获得二星
    3.如果索引中包含了查询中需要的全部列则获得三星

    非常小的表全表扫描更高效
    中到大型的表 索引很有效
    特大型表 则建议分区分库分表
    表很多时 可以建立元数据信息表


索引优化技巧:

    1.尽可能将需要做范围查询的列放在索引的后面 以便优化器能使用尽可能多的索引列
    2.对于范围条件查询 无法再使用范围列后面的其他索引项了 但是对于多个等值查询则没有这样的限制
    3.
    
   




Schema与数据类型优化

    1.选择优化的的数据类型 
    a.更小的通常更好
    b.简单就好  简单数据类型的操作通常需要更小的CPU周期
    例如应该使用内建的类型而不是使用字符串来存储日期和时间
    c.尽量避免使用null 因为可为null的列使得索引 索引统计和值比较都更复杂一点
    但是innodb使用单独的bit位存储null值 所有在innodb上可以不用在意这个准则
    2.使用枚举类型代替常用的字符串类型  enum（） 在.frm文件中会存放对应的映射关系
    内部会保存为整数 如enum('fish','apple') 对应于1 2 
    3.标识列选择 整数类型通常是最好的选择 因为他们很快并且可以使用 auto_increment 

    善用汇总表 ；物化视图

    数据类型种类
    1.整形 tinyint smallint mediumint int bigint 8 16 24 32 64
    对于存储和计算来说 int(1)和int(20)是相同的 区别只是显示的字符个数不同
    2.实数类型 decimal float double decimal每4个字节存储9的数字 最多允许65个数字
    float 4字节 double 8字节
    3.字符类型  varchar char 每个存储引擎实现细节不一样 总的来说
    varchar 不定长 char定长  ()里面放的是字符数 
    varchar 使用1或者2个字节存储字符长度 对于一个字符就是一个字节的编码来说 varchar(10) 需要11个字节 括号里面
    表示的是字节数 它节省了存储空间 但是一旦update时 如果varchar变得更长 可能需要分裂页
    使用场景:字符串列的最大长度比平均长度大的多;列的更新很少;使用了像utf-8这样复杂的字符集 
    每个字符使用不同的字节数进行存储
    
    char 定长 存储char值时会自动删除末尾所有的空格 
    适合存储很短的字符串 对于经常变更的数据 一般来说char比varchar更好 
    
    binary  varbinary 二进制字符串 存储的是字节码 二进制字符串比较比char这种更快 
    
    blob text 类型 为更大数据准备 分别采用二进制和字符方式存储 当这两种类型太大时
    innodb为使用专门的外部存储区域进行存储 此时行内存储指向存储地方的指针
    
    4.日期和时间类型
    datetime timestamp 
    datetime 范围从1001到9999年 精度为秒 存储格式为整数 8个字节 与时区无关
    timestamp 保存1970年1月1日以来的秒数 4个字节 最多表示到2038年 依赖时区 对于同一个timestamp
    在不同的地方显示不同 

    5.位类型
    bit 最多64个位 mysql会将bit当作字符串类型 
    set bit的集合 


    schema设计优化
    1.不要使用太多的列 
    mysql服务器层将行缓冲内容解码为各个列 列太多性能会出问题
    2.不要使用太多关联 单个查询最好在12个表以内做关联 

    范式的优点和缺点
    1.对于写密集的场景 范式化的更新操作比反范式化要块
    2.修改只需要修改更少的数据
    3.表更小 更好的放在内存中 操作更快
    4.更少使用group by distinct 
    缺点 需要关联 可能会使索引失效
    
    反范式的优点和缺点
    1.避免关联
    2.数据冗余
    
    加快alter table的速度
    执行大部分修改表结构的方法是用新的结构创建一个空表 从旧表中查出所有数据插入新表 然后删除旧表
    1.在备用机器上执行alter table操作 然后和主库进行切换
    2.影子拷贝 先创建一张和原表无关的新表 然后通过重命名和删除操作交换两张表
    3.修改.frm文件
    
    

查询性能优化:
    
    查询性能优化需要从查询优化 索引优化 和库表结构优化三个方面入手。

    为什么查询会慢？
    1.查询了不需要的记录 Mysql从引擎层返回结果集后再计算
    2.多表关联时返回所有列
    3.总是取出所有列 即select *
    4.重复查询相同的数据 此时用缓存比较好 

    如何衡量慢查询？
    最简单的三个指标:相应时间 扫描的行数 以及返回的行数
    响应时间为服务时间和排队时间 如果扫描行数比返回行数大的多 可以考虑使用索引覆盖
    
    如何重构查询:
    1.将复杂查询转化成简单查询 切分查询 比如删除旧的数据 可以每次删一点
    2.分解关联查询
    
    查看查询状态 show full processlist 状态值有 sleep query locked 
    analying and statistics copy to temp table sorting result
    sending data 

    特定类型的优化
    1.优化count() 它可以统计一列中非空数量 还可以统计结果集行数 
    使用近似值 增加汇总表 
    2.优化关联查询 确保on或者using 子句中的列有索引 确保任何的group by order by中的
    表达式只涉及一个表中的列 
    3.distinct 、 group by优化 group by 无法使用索引时 会通过使用临时表或者文件排序来分组 
    通常group by使用标识列的效果更好
    4.Limit优化 对于1000，20这样的查询 需要查询1020条并且丢弃前面的1000条
    可以通过延迟关联解决 即获得需要访问的记录后再回原表查询所需要的列
    另外可以将Limit查询转化成已知位置的查询
    使用书签记录上次取数据的位置 下次从该位置开始扫描 
    使用预先计算的汇总表
    关联到一个冗余表 表里面只有主键列和需要做排序的数据列
    先获取并缓存较多的数据
    5.union优化 mysql通过创建并填充临时表的方式来执行union查询 
    6.用户自定义变量
    



复制-10

    两种复制方式:基于行的复制方式和基于语句的复制方式
    复制的作用:数据分布、负载均衡、备份、升级测试
    步骤:
    1.在主库上把数据更改记录到二进制日志中 
    2.备库将主库的日志复制到自己的relay log中
    3.备库读取中继日志中的事件 将其重放到备库数据上
    具体来说:
    1.在每次准备提交事务完成数据更新前 主库将数据更新的事件记录到二进制日志中  
    按照事务的提交顺序而不是每条语句的执行顺序记录二进制日志
    2.备库将主库的二进制日志复制到本地的中继日志中 首先，备库会启动一个工作
    线程 称为IO线程 它负责与主库建立一个普通的客户端连接 然后在主库上启动一个
    特殊的binlog dump线程 负责读取二进制日志中的事件
    备库的SQL线程完成最后一步 从中继日志中读取事件并在备库执行
    
    基于语句的复制 优点-实现简单，简单的记录和执行这些语句就能主备同步
    
    
    